loan,data = dat_train)
svm_lin_wf <-workflow()%>% add_model(svm_linear_mod%>%set_args(cost=tune()))%>% add_recipe(dat_rec)
svm_rad_wf <-workflow()%>% add_model(svm_rad_mod%>%set_args(cost=tune(),
rbf_sigma=tune()))%>% add_recipe(dat_rec)
# Echantillonnage pour le calcul des paramètres (Cross validation)
df_folds<-vfold_cv(training(split_dat),v=5,strata=y)
# Grille d'optimisation pour le paramètre de la svm
svm_lin_grid <-grid_regular(cost(),levels=5)
tune_res_svm_lin <-tune_grid(svm_lin_wf, resamples=df_folds, grid=svm_lin_grid)
?cost()
# Grille d'optimisation pour le paramètre de la svm
svm_lin_grid <-grid_regular(cost(0, -10),levels=5)
# Grille d'optimisation pour le paramètre de la svm
svm_lin_grid <-grid_regular(cost(0),levels=5)
# Grille d'optimisation pour le paramètre de la svm
svm_lin_grid <-grid_regular(cost(range = c(0, -10)),levels=5)
tune_res_svm_lin <-tune_grid(svm_lin_wf, resamples=df_folds, grid=svm_lin_grid)
# Grille d'optimisation pour le paramètre de la svm
svm_lin_grid <-grid_regular(cost(range = c(0, -1)),levels=5)
tune_res_svm_lin <-tune_grid(svm_lin_wf, resamples=df_folds, grid=svm_lin_grid)
train<- sample(1:nrow(data), 33908)
lda.fit<-lda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
qda.fit<- qda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
res.lda<- predict(lda.fit, data[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
tablda<- roc(Realite, res.lda$posterior)
tablda<- roc(Realite, res.lda$posterior[,17])
res.lda<- predict(lda.fit, data[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,2])
tabqda<-roc(Realite, res.qda$posterior[,2])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
library(FactoMineR)
library(factoextra)
library(graphics)
library(ggplot2)
library(tinytex)
library(dplyr)
library(DT)
library(ggpubr)
library(questionr)
library(tikzDevice)
library(ggthemes)
library(patchwork)
library(visdat)
theme_set(theme_minimal())
library(knitr)
library(kableExtra)
library(tidyverse)
library(tidymodels)
library(pROC)
library(plotROC)
library(ROCR)
library(precrec)
library(kernlab)
library(randomForest)
library(discrim)
library(ISLR)
library(MASS)
library(e1071)
library(dplyr)
library(caret)
library(rsample)
library(rpart)
library(rpart.plot)
# Nouvelles librairies
library(mlbench)
library(gmodels)
library(class)
library(parallel)
library(doParallel)
library(MLmetrics)
library(tree)
data <- read.csv2('train.csv', header = TRUE, sep = ";")
head(str(data))
# Transformations des variables catégorielles jusqu'à lors considérées comme des caractères en facteurs
data$job <- factor(data$job, levels = c("unknown","unemployed","services","management","blue-collar","self-employed", "technician","entrepreneur","admin.", "student","housemaid", "retired" ))
data$marital <- factor(data$marital, levels = c('single', 'divorced', 'married'))
data$education <- factor(data$education, levels = c('unknown', 'primary', 'secondary', 'tertiary'))
data$month<- factor(data$month)
data$contact <- factor(data$contact, levels = c('unknown', 'cellular', 'telephone'))
data$poutcome <- factor(data$poutcome, levels = c('unknown', 'other', 'failure', 'success'))
data <- data %>%
mutate(default = factor(default),
housing = factor(housing),
loan = factor(loan),
y = factor(y))
str(data)
train<- sample(1:nrow(data), 33908)
lda.fit<-lda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
qda.fit<- qda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
res.lda<- predict(lda.fit, data[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
lda.fit<-lda(y~., data=data[train,])
qda.fit<- qda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
res.lda<- predict(lda.fit, data[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
data.frame(AUC=c(lda=auc(tablda), qda=auc(tabqda))) %>%
kable()
res.lda$posterior[,1]
res.lda$posterior
res.lda<- predict(lda.fit, data[-train,],
decision.values=F)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
tune.out.svm.lin<-tune(svm,
y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,],
kernel="linear",
ranges=list(cost=c(0.001,0.01,0.1, 1, 5, 10, 100)))
data_boost <- read.csv2('train.csv', header = TRUE, sep = ";")
head(str(data_boost))
# Transformations des variables catégorielles jusqu'à lors considérées comme des caractères en facteurs
data_boost$job <- factor(data_boost$job, levels = c("unknown","unemployed","services","management","blue-collar","self-employed", "technician","entrepreneur","admin.", "student","housemaid", "retired" ))
data_boost$marital <- factor(data_boost$marital, levels = c('single', 'divorced', 'married'))
data_boost$education <- factor(data_boost$education, levels = c('unknown', 'primary', 'secondary', 'tertiary'))
data_boost$month<- factor(data_boost$month)
data_boost$contact <- factor(data_boost$contact, levels = c('unknown', 'cellular', 'telephone'))
data_boost$poutcome <- factor(data_boost$poutcome, levels = c('unknown', 'other', 'failure', 'success'))
data_boost <- data_boost %>%
mutate(default = factor(default),
housing = factor(housing),
loan = factor(loan),
y = factor(y))
str(data_boost)
# Adaboost
set.seed(1)
split_data_boost <- initial_split(data_boost, prop = 0.75, strata = y)
data_boost_train <- training(split_data_boost)
data_boost_test <- testing(split_data_boost)
# En jouant sur l’argument control de ada, on peut jouer sur le type d’arbre construit à chaque itération. Créer un objet boostump correspondant à un boosting sur des stumps, c’est-à-dire des arbes à 2 feuilles avec 500 itérations.
boostump <- ada(y ~ .,
data = data_boost_train, type = "discrete", loss = "exponential",
control = rpart.control(maxdepth=1,cp=-1,minsplit=0,xval=0), iter = 50, nu = 1)
# Observer l'objet/modèle créé
boostump
summary(boostump)
plot(boostump)
# Réaliser des boostings en intégrant une pénalisation (boostpen01 pour une pénalisation à 0.1 et boostpen001 pour une pénalisation à 0.01).
boostpen01 <- ada(y ~ .,
data = data_boost_train, type = "discrete", loss = "exponential",
control = rpart.control(cp = 0), iter = 50, nu = 0.1
)
boostpen001 <- ada(y ~ .,
data = data_boost_train, type = "discrete", loss = "exponential",
control = rpart.control(cp = 0), iter = 50, nu = 0.01
)
# Adaboost
set.seed(1)
split_data_boost <- initial_split(data_boost, prop = 0.75, strata = y)
data_boost_train <- training(split_data_boost)
data_boost_test <- testing(split_data_boost)
# Optimisation de l'adaboost avec Caret
ncore <- 6
registerDoParallel(cores = ncore - 1)
registerDoParallel(cores = ncore - 1)
# lancement de la commande à l'identique
ctrlCv <- trainControl(method = "repeatedcv",
repeats = 2, number = 5)
adaGrid <- expand.grid(maxdepth = 10,
iter = c(10, 20, 50, 100),
nu = c(1, 0.01, 0.1))
system.time(caretada <- train(y ~ .,
data = data_boost_train, method = "ada",
trControl = ctrlCv, tuneGrid = adaGrid
))
confusionMatrix(data = predict(arbre, test_data, type='class'),
reference = pull(test_data, y),
mode = "everything", positive = "no")
knitr::opts_chunk$set(message = FALSE, warning = FALSE, sanitize = TRUE, echo = FALSE, cache = TRUE)
tune.out.svm.lin<-tune(svm,
y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,],
kernel="linear",
ranges=list(cost=c(0.001,0.01,0.1, 1, 5, 10, 100)))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, sanitize = TRUE, echo = FALSE, cache = TRUE)
library(FactoMineR)
library(factoextra)
library(graphics)
library(ggplot2)
library(tinytex)
library(dplyr)
library(DT)
library(ggpubr)
library(questionr)
library(tikzDevice)
library(ggthemes)
library(patchwork)
library(visdat)
theme_set(theme_minimal())
library(knitr)
library(kableExtra)
library(tidyverse)
library(tidymodels)
library(pROC)
library(plotROC)
library(ROCR)
library(precrec)
library(kernlab)
library(randomForest)
library(discrim)
library(ISLR)
library(MASS)
library(e1071)
library(dplyr)
library(caret)
library(rsample)
library(rpart)
library(rpart.plot)
# Nouvelles librairies
library(mlbench)
library(gmodels)
library(class)
library(parallel)
library(doParallel)
library(MLmetrics)
library(tree)
train <- read.csv2('train.csv', header = TRUE, sep = ";")
head(str(train))
library(visdat)
vis_dat(train, palette = "default")
# Transformations des variables catégorielles jusqu'à lors considérées comme des caractères en facteurs
train$job <- factor(train$job, levels = c("unknown","unemployed","services","management","blue-collar","self-employed", "technician","entrepreneur","admin.", "student","housemaid", "retired" ))
train$marital <- factor(train$marital, levels = c('single', 'divorced', 'married'))
train$education <- factor(train$education, levels = c('unknown', 'primary', 'secondary', 'tertiary'))
train$month<- factor(train$month)
train$contact <- factor(train$contact, levels = c('unknown', 'cellular', 'telephone'))
train$poutcome <- factor(train$poutcome, levels = c('unknown', 'other', 'failure', 'success'))
train$contact <- factor(train$contact, levels = c('unknown', 'cellular', 'telephone'))
train$poutcome <- factor(train$poutcome, levels = c('unknown', 'other', 'failure', 'success'))
train <- train %>%
mutate(default = factor(default),
housing = factor(housing),
loan = factor(loan),
y = factor(y))
str(train)
levels(train$default)
train <- train %>%
mutate(default = factor(default),
housing = factor(housing),
loan = factor(loan),
y = factor(y))
vis_dat(train, palette = "default")
vis_dat(train, palette = "default")
summary(train)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, sanitize = TRUE, echo = FALSE, cache = TRUE)
library(FactoMineR)
library(factoextra)
library(graphics)
library(ggplot2)
library(tinytex)
library(dplyr)
library(DT)
library(ggpubr)
library(questionr)
library(tikzDevice)
library(ggthemes)
library(patchwork)
library(visdat)
theme_set(theme_minimal())
library(knitr)
library(kableExtra)
library(tidyverse)
library(tidymodels)
library(pROC)
library(plotROC)
library(ROCR)
library(precrec)
library(kernlab)
library(randomForest)
library(discrim)
library(ISLR)
library(MASS)
library(e1071)
library(dplyr)
library(caret)
library(rsample)
library(rpart)
library(rpart.plot)
# Nouvelles librairies
library(mlbench)
library(gmodels)
library(class)
library(parallel)
library(doParallel)
library(MLmetrics)
library(tree)
data <- read.csv2('train.csv', header = TRUE, sep = ";")
head(str(data))
library(visdat)
vis_dat(data, palette = "default")
# Transformations des variables catégorielles jusqu'à lors considérées comme des caractères en facteurs
data$job <- factor(data$job, levels = c("unknown","unemployed","services","management","blue-collar","self-employed", "technician","entrepreneur","admin.", "student","housemaid", "retired" ))
data$marital <- factor(data$marital, levels = c('single', 'divorced', 'married'))
data$education <- factor(data$education, levels = c('unknown', 'primary', 'secondary', 'tertiary'))
data$month<- factor(data$month)
data$contact <- factor(data$contact, levels = c('unknown', 'cellular', 'telephone'))
data$poutcome <- factor(data$poutcome, levels = c('unknown', 'other', 'failure', 'success'))
data <- data %>%
mutate(default = factor(default),
housing = factor(housing),
loan = factor(loan),
y = factor(y))
vis_dat(data, palette = "default")
summary(data)
set.seed(1)
split_data <- initial_split(train, prop = 0.75, strata = y)
data_train <- training(split_data)
data_test <- testing(split_data)
train<- sample(1:nrow(data), 33908)
lda.fit<-lda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
qda.fit<- qda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,])
res.lda<- predict(lda.fit, data[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data[-train,])
Realite<- data$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
data.frame(AUC=c(lda=auc(tablda), qda=auc(tabqda))) %>%
kable()
auc(tablda)
train$job <- fct_recode(train$job, NULL = "unknown")
data_2 <- data
data_2$job <- fct_recode(data_2$job, NULL = "unknown")
data_2$education <- fct_recode(data_2$education, NULL = "unknown")
data_2$contact <- fct_recode(data_2$contact, NULL = "unknown")
data_2$poutcome <- fct_recode(data_2$poutcome, NULL = "unknown")
sum(is.na(data_2))
data_2%>% tidyr::drop_na()
data_2<- data_2%>% tidyr::drop_na()
sum(is.na(data_2))
lda.fit<-lda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data_2[train,])
qda.fit<- qda(y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data_2[train,])
res.lda<- predict(lda.fit, data_2[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data_2[-train,])
Realite<- data_2$y[-train]
tablda<- roc(Realite, res.lda$posterior[,1])
tabqda<-roc(Realite, res.qda$posterior[,1])
# erreur à corriger
# ggroc(list(lda=tablda, qda = tabqda)) +
#   ggtitle("Courbe Roc LDA / QDA")
data.frame(AUC=c(lda=auc(tablda), qda=auc(tabqda))) %>%
kable()
ggroc(list(lda=tablda, qda = tabqda)) +
ggtitle("Courbe Roc LDA / QDA")
data.frame(AUC=c(lda=auc(tablda), qda=auc(tabqda))) %>%
kable()
tablda
tabqda
ggroc(list(lda=tablda, qda = tabqda))
tabqda
tabqda
tablda
tabqda
tablda
data.frame(AUC=c(lda=auc(tablda), qda=auc(tabqda)))
# erreur à corriger
# ggroc(list(lda=tablda, qda = tabqda)) +
#   ggtitle("Courbe Roc LDA / QDA")
tablda$percent
# erreur à corriger
# ggroc(list(lda=tablda, qda = tabqda)) +
#   ggtitle("Courbe Roc LDA / QDA")
tablda$sensitivities
# erreur à corriger
# ggroc(list(lda=tablda, qda = tabqda)) +
#   ggtitle("Courbe Roc LDA / QDA")
tablda$auc
# erreur à corriger
# ggroc(list(lda=tablda, qda = tabqda)) +
#   ggtitle("Courbe Roc LDA / QDA")
tablda$predictor
# erreur à corriger
ggroc(list(lda=tablda$predictor, qda = tabqda$predictor)) +
ggtitle("Courbe Roc LDA / QDA")
# erreur à corriger
ggroc(list(lda=tablda$predictor, qda = tabqda$predictor)) +
ggtitle("Courbe Roc LDA / QDA")
tablda<- roc(Realite, res.lda$posterior)
res.lda<- predict(lda.fit, data_2[-train,],
decision.values=T)
res.qda<- predict(qda.fit, data_2[-train,])
Realite<- data_2$y[-train]
tablda<- roc(Realite, res.lda$posterior)
roc(Realite, res.lda$posterior)
roc(Realite, res.lda$posterior[,1])
tune.out.svm.lin<-tune(svm,
y~job+
marital+
education+
month+
contact+
poutcome+
default+
housing+
loan, data=data[train,],
kernel="linear",
ranges=list(cost=c(0.001,0.01,0.1, 1, 5, 10)))
